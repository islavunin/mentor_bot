'''Telegram bot for Optiteam mentor activity'''

from datetime import date, time, datetime
import logging
#from logging.handlers import RotatingFileHandler
import configparser
import json
from pytz import timezone


from telegram import InlineKeyboardMarkup, Update
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters
)

from bot_utils import (
    get_om_list,
    get_om_mc,
    make_buttons,
    reg_user_in_om,
    get_chat_member,
    write_selection,
    make_mentor_cards,
    write_assessment
)

config = configparser.ConfigParser()
config.read('config.ini')
TBOT_TOKEN = config.get('tgbot', 'TOKEN')

# Global variables
comp_matrix = get_om_list('–û–±–ª–∞—Å—Ç–∏ —ç–∫—Å–ø–µ—Ä—Ç–∏–∑—ã –¥–ª—è –±–æ—Ç–∞')
users_df = get_om_mc('ML Users')


# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.DEBUG,
    filename='basic.log',
    encoding='utf-8')

# Set rotating logger
#logger = logging.getLogger(__name__)
#logger.setLevel(logging.DEBUG)
#formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

#handler = RotatingFileHandler("basic.log",
#                              mode='a',
#                              maxBytes=1000000,
#                              backupCount=1,
#                              encoding='utf-8',
#                              delay=0)
#handler.setLevel(logging.DEBUG)
#handler.setFormatter(formatter)

#logger.addHandler(handler)

# Set higher logging level for httpx to avoid all GET and POST requests being logged
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.INFO)
logging.getLogger("httpcore").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.INFO)

logger = logging.getLogger(__name__)


def get_user_df(df, user_id):
    '''get_user_df'''
    try:
        df = df[df.Telegram_id == str(user_id)]
    except AttributeError:
        df = get_om_mc('ML Users')
        df = df[df.Telegram_id == str(user_id)]
    return df


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a message with three inline buttons attached."""
    user = '@' + update.effective_user.username
    user_id = update.effective_user.id
    req = get_chat_member(user_id)
    logger.debug("get_chat_member, %s", req)
    #check if user in OT chat
    if not req['ok']:
        await update.message.reply_text(
            f"–ü—Ä–∏–≤–µ—Ç, {user}! –≠—Ç–∏–º –±–æ—Ç–æ–º –º–æ–≥—É—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ –û–¢ –∏ –û–ú, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ—Å—Ç–æ—è—Ç –≤ –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ üòâ")
    elif req['result']['status'] == 'kicked' or req['result']['status'] == 'left':
        await update.message.reply_text(
            f"–ü—Ä–∏–≤–µ—Ç, {user}! –¢—ã –±—ã–ª —É–¥–∞–ª–µ–Ω –∏–∑ –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ —á–∞—Ç–∞ –ì–ö –û–ø—Ç–∏–º–∞–∫—Ä–æ—Å. –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Ç—ã –Ω–µ –º–æ–∂–µ—à—å –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º üòî")
    else:
        await update.message.reply_text(
                f"–ü—Ä–∏–≤–µ—Ç, {user}, –ø–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ üôèüèº")
        global users_df
        #logger.debug("get_om_mc('ML Users')")
        users_df = get_om_mc('ML Users')
        user_df = users_df[users_df.Telegram_id == str(update.effective_user.id)]
        #user_df = get_user_df(users_df, user_id)
        om_user = user_df['–ü–æ—á—Ç–∞']
        #check if user had already connected before
        if not om_user.empty:
            #check if user had mentors today
            #sends a competention quiz
            if user_df['–ù–µ—Ç –æ—Ü–µ–Ω–∫–∏'].item() == "1":
                await update.message.reply_text(
                f"{user}, –ø—Ä–µ–∂–¥–µ, —á–µ–º –ø–æ–¥–æ–±—Ä–∞—Ç—å –Ω–æ–≤–æ–≥–æ —ç–∫—Å–ø–µ—Ä—Ç–∞, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ—Ü–µ–Ω–∏—Ç—å —Ä–∞–±–æ—Ç—É –º–µ–Ω—Ç–æ—Ä–∞ –ø–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É –æ–±—Ä–∞—â–µ–Ω–∏—é üßê")
                await assess_mentor(update, context)
            else:
                day = date.today().strftime("%d/%m/%y")
                om_filter = f"ITEM(Users) = Users.'{om_user.item()}' AND ITEM(Days) = DAY(DATE(\"{day}\"))"
                #global assessment_df
                logger.debug("get_om_mc('–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å –º–µ–Ω—Ç–æ—Ä–æ–º'), filter: %s", om_filter)
                assessment_df = get_om_mc(
                    '–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å –º–µ–Ω—Ç–æ—Ä–æ–º',
                    view='4BOT',
                    formula=om_filter)
                logger.debug(assessment_df)
                if assessment_df['–í—ã–±—Ä–∞–Ω–Ω—ã–π –º–µ–Ω—Ç–æ—Ä —Ç–µ–∫—Å—Ç'].item() != "":
                    await update.message.reply_text(
                    f"{user}, –ø—Ä–æ—Å—Ç–∏, –º–æ–∂–Ω–æ –ø–æ–¥–æ–±—Ä–∞—Ç—å –Ω–µ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ –º–µ–Ω—Ç–æ—Ä–∞ –≤ –¥–µ–Ω—å!")
                else:
                    await comp_quiz(update, context)
        else:
            #sends a message to register
            await register(update, context)
            

async def register(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a message to register."""
    # if user not in OT - All cons then "–í—ã –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ —á–∞—Ç–µ"
    message = '''–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç–∞ –ø–æ –ø–æ–∏—Å–∫—É –∏ –ø–æ–¥–±–æ—Ä—É —ç–∫—Å–ø–µ—Ä—Ç–æ–≤ 
—Å—Ä–µ–¥–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –û–ø—Ç–∏–¢–∏–º –∏ –û–ø—Ç–∏–º–∞–∫—Ä–æ—Å.
–ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ä–∞–±–æ—Ç—É, –Ω—É–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –∫–æ—Ä–æ—Ç–∫—É—é —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é!

üëâ–ù–∞–ø–∏—à–∏ —Å–≤–æ—é —Ä–∞–±–æ—á—É—é —ç–ª. –ø–æ—á—Ç—É

–ü—Ä–∏–º–µ—Ä: i.ivanov@optiteam.ru

–¢–∞–∫–∂–µ, –µ—Å–ª–∏ —Ç—ã –Ω–µ –ø—Ä–æ—Ç–∏–≤, –º—ã –∑–∞–ø–∏—à–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–≤–æ–µ–≥–æ —Ç–µ–ª–µ–≥—Ä–∞–º-–∞–∫–∫–∞—É–Ω—Ç–∞ –≤ –º–æ–¥–µ–ª—å Human capital 
–∏ –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –±–æ—Ç –±—É–¥–µ—Ç —É–∑–Ω–∞–≤–∞—Ç—å —Ç–µ–±—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏'''
    await update.message.reply_text(message)


async def login(update, context) -> None:
    """Check login in OM model"""
    om_user = update.message.text
    tg_id = str(update.effective_user.id)
    tg_username = str(update.effective_user.username)
    global users_df
    user_df = users_df[users_df['–ü–æ—á—Ç–∞'] == om_user]
    if user_df.empty:
        msg = '''–•–º, –≤ –º–æ–¥–µ–ª–∏ –Ω–µ—Ç —Ç–∞–∫–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è! üßê
–ù–∞–ø–∏—à–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∞–¥—Ä–µ—Å —Ä–∞–±–æ—á–µ–π –ø–æ—á—Ç—ã.'''
        await update.message.reply_text(msg)
    elif user_df.Telegram_id.item() and user_df.Telegram_id.item() != tg_id:
        #msg = f'–î–∞–Ω–Ω—ã–π email —É–∂–µ —É–∫–∞–∑–∞–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{user_df.Telegram_login.item()}!'
        msg = '''–•–º, —ç—Ç–æ—Ç e-mail —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω üßê
–ù–∞–ø–∏—à–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∞–¥—Ä–µ—Å —Å–≤–æ–µ–π —Ä–∞–±–æ—á–µ–π –ø–æ—á—Ç—ã.'''
        await update.message.reply_text(msg)
    else:
        reg_user_in_om(om_user, tg_id, tg_username)
        await update.message.reply_text(
                f"–ü–æ–¥–æ–∂–¥–∏ —á—É—Ç—å-—á—É—Ç—å, {tg_username}, —Å–æ—Å—Ç–∞–≤–ª—è–µ–º –æ–ø—Ä–æ—Å–Ω–∏–∫!")
        users_df = get_om_mc('ML Users')
        await comp_quiz(update, context)


async def comp_quiz(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    '''comp_quiz'''
    message = 'üëâ –£–∫–∞–∂–∏ –æ—Å–Ω–æ–≤–Ω—É—é –æ–±–ª–∞—Å—Ç—å, –≤ –∫–æ—Ç–æ—Ä–æ–π —Ç–µ–±–µ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–º–æ—â—å –º–µ–Ω—Ç–æ—Ä–∞'
    keyboard = make_buttons(comp_matrix)
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(message, reply_markup=reply_markup)


async def edit_query_message(query, msg):
    '''edit_query_message'''
    await query.edit_message_text(text=msg)


async def compententions_quiz(context, query, answer_list, tg_username, om_user, om_grade):
    '''compententions_quiz'''
    code = answer_list[1]
    if code == 'back':
        keyboard = make_buttons(comp_matrix)
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_reply_markup(reply_markup=reply_markup)
    else:
        answer = comp_matrix[comp_matrix['Code'] == code]['Entity'].item()
        payload = {
            tg_username: {
                "domain": answer,
            }
        }
        context.bot_data.update(payload)
        logger.debug('Comp answer is %s, code is %s', answer, code)
        if not comp_matrix[comp_matrix.Parent == answer].empty:
            keyboard = make_buttons(comp_matrix, answer)
            reply_markup = InlineKeyboardMarkup(keyboard)
            #logger.debug('message_reply_markup \n%s', str(reply_markup))
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        #if user choosed final point of quiz
        else:
            await query.edit_message_text(text=
                f'–ü–æ–¥–æ–∂–¥–∏ —á—É—Ç—å-—á—É—Ç—å, @{tg_username}, –ø–æ–¥–±–∏—Ä–∞—é –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ —Ç–µ–º–µ "{answer}"üîç')
            om_formula = f'NAME(ITEM(\'Grades\')) = "{om_grade}" AND NAME(ITEM(\'–û–±–ª–∞—Å—Ç–∏ —ç–∫—Å–ø–µ—Ä—Ç–∏–∑—ã –¥–ª—è –±–æ—Ç–∞\')) = "{answer}"'
            logger.debug("get_om_mc('–î–∞–Ω–Ω—ã–µ –¥–ª—è –±–æ—Ç–∞ –ø–æ –º–µ–Ω—Ç–æ—Ä—É', formula=%s)", om_formula)
            df = get_om_mc('–î–∞–Ω–Ω—ã–µ –¥–ª—è –±–æ—Ç–∞ –ø–æ –º–µ–Ω—Ç–æ—Ä—É –≤ —Ä–∞–∑—Ä–µ–∑–µ –≥—Ä–µ–π–¥–æ–≤', formula=om_formula)
            mentors = df['–î–∞–Ω–Ω—ã–µ'].item()
            mentors = json.loads(mentors.replace('\'', '"'))
            msg, kb = make_mentor_cards(om_user, mentors, code, answer)
            logger.debug("make_mentor_cards, %s", kb)
            reply_markup = InlineKeyboardMarkup(kb)
            await query.edit_message_text(text=
                msg)
            await query.edit_message_reply_markup(reply_markup=reply_markup)


async def mentors_choise(query, answer_list, om_user):
    '''mentors_choise'''
    dis_name = answer_list[1]
    domain = comp_matrix[comp_matrix['Code'] == answer_list[2]]['Entity'].item()
    if dis_name == 'own':
        msg = f'üëâ–ù–∞–ø–∏—à–∏ —Ç–æ—á–Ω—ã–π –¥–∏—Å–∫–æ—Ä–¥-–Ω–∏–∫ –º–µ–Ω—Ç–æ—Ä–∞, –∫ –∫–æ—Ç–æ—Ä–æ–º—É —Ç—ã —Ö–æ—á–µ—à—å –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è (–±–µ–∑ @) –ø–æ —Ç–µ–º–µ {domain}'
        await query.edit_message_text(text=msg)
    else:
        name = users_df[users_df['discord'] == dis_name]['name'].item()
        msg = f'''–ú–µ–Ω—Ç–æ—Ä –ø–æ —Ç–µ–º–µ "{domain}" –≤—ã–±—Ä–∞–Ω - {name}!
üì© –°–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω—Ç–æ—Ä–æ–º –º–æ–∂–Ω–æ –≤ Discord - {dis_name}

1. –û–ø–∏—à–∏ —Å–≤–æ–π –∫–µ–π—Å.
2. –î–æ–≥–æ–≤–æ—Ä–∏—Å—å —Å –º–µ–Ω—Ç–æ—Ä–æ–º –æ–± —É–¥–æ–±–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Å–æ–∑–≤–æ–Ω–∞ 1-1. 
–í–∞–º –≤—ã–¥–µ–ª—è–µ—Ç—Å—è 4 —á–∞—Å–∞ –Ω–∞ —Ä–µ—à–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞, –∏—Ö –º–æ–∂–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–∫ —É–¥–æ–±–Ω–æ.  
–§–ê/–¢–ê/–≠—Ç–∞–ø –¥–ª—è –≤—Å—Ç—Ä–µ—á–∏: OT_–ü—Ä–æ—á–∏–µ HR –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ 2024, –ü—Ä–æ—á–∏–µ HR –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏, –ù–∞—Å—Ç–∞–≤–Ω–∏—á–µ—Å—Ç–≤–æ.
3. –ü–æ—Å–ª–µ —Ä–µ—à–µ–Ω–∏—è –≤–æ–ø—Ä–æ—Å–∞ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –æ—Ü–µ–Ω–∏—Ç—å —Ä–∞–±–æ—Ç—É —Å –º–µ–Ω—Ç–æ—Ä–æ–º –ø–æ 5-–±–∞–ª—å–Ω–æ–π —à–∫–∞–ª–µ, –≥–¥–µ 5 - –Ω–∞–∏–≤—ã—Å—à–∞—è –æ—Ü–µ–Ω–∫–∞ (–≤–æ–ø—Ä–æ—Å —Ä–µ—à–µ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é, –≤–∑–∞–∏–º–æ–¥–π—Å—Ç–≤–∏–µ –±—ã–ª–æ –∫–æ–º—Ñ–æ—Ä—Ç–Ω—ã–º). 
üëâ –î–ª—è –æ—Ü–µ–Ω–∫–∏ –º–µ–Ω—Ç–æ—Ä–∞ –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /mentor
–ï—Å–ª–∏ —Ä–∞–∑–æ–±—Ä–∞–ª—Å—è —Å–∞–º –∏–ª–∏ –æ—à–∏–±—Å—è —Å –≤—ã–±–æ—Ä–æ–º –º–µ–Ω—Ç–æ—Ä–∞, –≤—Å–µ —Ä–∞–≤–Ω–æ –ø—Ä–æ–π–¥–∏ –≤ –º–µ–Ω—é –æ—Ü–µ–Ω–∫–∏ –∏ –≤—ã–±–µ—Ä–∏ –æ—Ç–º–µ–Ω—É'''
        await query.edit_message_text(text=msg)
        day = date.today().strftime("%d.%m.%Y")
        write_selection(om_user, name, domain, day)


async def own_mentor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    '''own_mentor'''
    user = '@' + update.effective_user.username
    discord = update.message.text
    bot_data = context.bot_data[user[1:]]
    logging.debug("bot data %s", bot_data)
    domain = bot_data['domain']
    code = comp_matrix[comp_matrix.Entity == domain].Code.item()
    logger.debug('discord name: %s', discord)
    if users_df['discord'].isin([discord]).any():
        mentor_df = users_df[users_df['discord'] == discord]
        logger.debug('is_mentor: %s', mentor_df.is_mentor.item())
        if mentor_df.is_mentor.item() == '1':
            mentor_name = mentor_df['name'].item()
            skills = mentor_df['key_skills'].item().split(', ')
            message = f'''–Ø –Ω–∞—à–µ–ª –º–µ–Ω—Ç–æ—Ä–∞:
_______
üôÇ {mentor_name}
–î–æ–ª–∂–Ω–æ—Å—Ç—å: {mentor_df['–ì—Ä–µ–π–¥'].item()}
üìå –ö–ª—é—á–µ–≤—ã–µ –Ω–∞–≤—ã–∫–∏: 
- {skills[0]}
- {skills[1]}
- {skills[2]}
_______
‚ùî–ï—Å–ª–∏ –º–µ–Ω—Ç–æ—Ä —Ç–µ–±–µ –ø–æ–¥—Ö–æ–¥–∏—Ç, –Ω–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É —Å –∏–º–µ–Ω–µ–º –Ω–∏–∂–µ, –∞ —è –ø–æ–¥—Å–∫–∞–∂—É —Ç–µ–±–µ —Å–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏. 
‚ùî–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –Ω–∞—á–∞—Ç—å –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ, –Ω–∞–∂–º–∏ /start'''
            keyboard = [[{'text': mentor_name, 'callback_data': 'men_' + discord + '_' +  code }],
                        [{'text': "–ù–∞—á–∞—Ç—å —Å –Ω–∞—á–∞–ª–∞", 'callback_data': 'repeat' }]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(message, reply_markup=reply_markup)
        else:
            txt = f'''{user}, –ø—Ä–æ—Å—Ç–∏, —ç—Ç–æ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–µ–Ω—Ç–æ—Ä–æ–º. –Ø –Ω–µ –º–æ–≥—É –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –Ω–µ–º—É üòî
–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –Ω–∞—á–∞—Ç—å –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ, –Ω–∞–∂–º–∏ /start'''
            await update.message.reply_text(txt)
    else:
        txt = '''–•–º, —Ç–∞–∫–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç! üßê 
–ù–∞–ø–∏—à–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–∏—Å–∫–æ—Ä–¥-–Ω–∏–∫.'''
        await update.message.reply_text(txt)


def get_assessment_df(user_id):
    '''get_assessment_df'''
    user_df = get_user_df(users_df, user_id)
    om_user = user_df['–ü–æ—á—Ç–∞'].item()
    om_formula = f"NAME(ITEM('Users')) = \"{om_user}\" AND '–ù–µ—Ç –æ—Ü–µ–Ω–∫–∏' AND NOT IS_PARENT()"
    logger.debug("get_om_mc('–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å –º–µ–Ω—Ç–æ—Ä–æ–º', formula=%s)", om_formula)
    assessment_df = get_om_mc(
        '–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å –º–µ–Ω—Ç–æ—Ä–æ–º',
        view='4BOT',
        formula=om_formula)
    return [om_user, assessment_df]


async def assess_mentor(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """assess_mentor"""
    assessment_df = get_assessment_df(update.effective_user.id)[1]
    if assessment_df.empty:
        await update.message.reply_text("–£ —Ç–µ–±—è –Ω–µ—Ç –º–µ–Ω—Ç–æ—Ä–æ–≤ –¥–ª—è –æ—Ü–µ–Ω–∫–∏")
    else:
        mentor = assessment_df['–í—ã–±—Ä–∞–Ω–Ω—ã–π –º–µ–Ω—Ç–æ—Ä —Ç–µ–∫—Å—Ç'].item()
        day = assessment_df['Days'].item()
        dom = assessment_df['–í—ã–±—Ä–∞–Ω–Ω–∞—è —Ç–µ–º–∞ —Ç–µ–∫—Å—Ç'].item()
        #dom = comp_matrix[comp_matrix['Code'] == code]['Entity'].item()
        message = f'''üëâ–û—Ü–µ–Ω–∏ —Ä–∞–±–æ—Ç—É –º–µ–Ω—Ç–æ—Ä–∞ {mentor} –ø–æ —Ç–µ–º–µ {dom} –ø–æ 5-–±–∞–ª—å–Ω–æ–π —à–∫–∞–ª–µ,
–≥–¥–µ 5 - –Ω–∞–∏–≤—ã—Å—à–∞—è –æ—Ü–µ–Ω–∫–∞ (–≤–æ–ø—Ä–æ—Å —Ä–µ—à–µ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é, –≤–∑–∞–∏–º–æ–¥–π—Å—Ç–≤–∏–µ –±—ã–ª–æ –∫–æ–º—Ñ–æ—Ä—Ç–Ω—ã–º), 
–∞ 1 - –≤–æ–ø—Ä–æ—Å –Ω–µ —Ä–µ—à–µ–Ω —Å–æ–≤—Å–µ–º.
–ï—Å–ª–∏ —Ä–∞–∑–æ–±—Ä–∞–ª—Å—è —Å–∞–º –∏–ª–∏ –æ—à–∏–±—Å—è —Å –≤—ã–±–æ—Ä–æ–º –º–µ–Ω—Ç–æ—Ä–∞, —Ç–æ –≤—ã–±–µ—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç –≤ —Å–∞–º–æ–º –Ω–∏–∑—É'''
        keyboard = [[{'text': i, 'callback_data': f"assess_{str(i)}_{day}" }] for i in range(1, 6)]
        keyboard.append([{'text': '–†–∞–∑–æ–±—Ä–∞–ª—Å—è —Å–∞–º', 'callback_data': f"cancel_{day}" }])
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(message, reply_markup=reply_markup)


async def cancel_mentor(update) -> None:
    """cancel_mentor"""
    query = update.callback_query
    user_df = get_user_df(users_df, update.effective_user.id)
    om_user = user_df['–ü–æ—á—Ç–∞'].item()
    day = query.data.split("_")[1]
    day = datetime.strptime(day, "%d %b %y").strftime("%d.%m.%y")
    message = '–í—ã–±–æ—Ä –º–µ–Ω—Ç–æ—Ä–∞ –æ—Ç–º–µ–Ω–µ–Ω. –ß—Ç–æ–±—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å –ø–æ–¥–±–æ—Ä–∞ –º–µ–Ω—Ç–æ—Ä–∞ –≤–Ω–æ–≤—å, –Ω–∞–∂–º–∏ /start'
    await query.edit_message_text(text=message)
    name, domain = '', ''
    write_selection(om_user, name, domain, day)


async def assess_time(query, answer):
    '''assess'''
    q_list = ["–¥–æ 30 –º–∏–Ω", "30 –º–∏–Ω - 1 —á–∞—Å", "1-2 —á–∞—Å–∞", "2-3 —á–∞—Å–∞", "3-4 —á–∞—Å–∞"]
    answer = 'end' + answer
    message = 'üëâ–ö–∞–∫–æ–µ –≤—Ä–µ–º—è –ø–æ—Ç—Ä–µ–±–æ–≤–∞–ª–æ—Å—å –º–µ–Ω—Ç–æ—Ä—É –¥–ª—è –ø–æ–º–æ—â–∏?'
    await query.edit_message_text(text=message)
    keyboard = [[{'text': q_list[i], 'callback_data': f"{answer}_{i+1}" }] for i in range(5)]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_reply_markup(reply_markup=reply_markup)


async def end_assess(query, om_user, answer_list):
    '''assess_time'''
    assessment = answer_list[1]
    day = answer_list[2]
    period = answer_list[3]
    await query.edit_message_text(text='‚ù§Ô∏è–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ü–µ–Ω–∫—É!')
    keyboard = [[{'text': '–°–ø–∞—Å–∏–±–æ!', 'callback_data': 'finish'}],
                [{'text': '–ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ –º–µ–Ω—Ç–æ—Ä–∞.', 'callback_data': 'repeat'}]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_reply_markup(reply_markup=reply_markup)
    write_assessment(om_user, day, assessment, period)


async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Parses the CallbackQuery and updates the message text."""
    query = update.callback_query
    answer = query.data
    logger.debug('Answer is %s', answer)
    # CallbackQueries need to be answered, even if no notification to the user is needed
    # Some clients may have trouble otherwise. See https://core.telegram.org/bots/api#callbackquery
    await query.answer()
    tg_username = str(update.effective_user.username)
    user_df = get_user_df(users_df, update.effective_user.id)
    om_user = user_df['–ü–æ—á—Ç–∞'].item()
    om_grade = user_df['–ì—Ä–µ–π–¥'].item()
    answer_list = answer.split('_')
    answer_type = answer_list[0]
    #if user push final button
    if answer_type == 'finish':
        msg = '''Ciao! –í–∑–≤—Ä–∞—â–∞–π—Å—è, –µ—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –º–æ—è –ø–æ–º–æ—â—å.
–ß—Ç–æ–±—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å –ø–æ–¥–±–æ—Ä–∞ –º–µ–Ω—Ç–æ—Ä–∞ –≤–Ω–æ–≤—å, –Ω–∞–∂–º–∏ /start'''
        await edit_query_message(query, msg)
    #if user asked to repead quiz
    elif answer_type == 'repeat':
        await edit_query_message(query, 'üëâ–ù–∞–∂–º–∏ /start')
    #if user choosed mentor
    elif answer_type == 'men':
        await mentors_choise(query, answer_list, om_user)
    #if user choosed assessment for mentor
    elif answer_type == 'assess':
        await assess_time(query, answer)
    #if user choosed time assessment
    elif answer_type == 'endassess':
        await end_assess(query, om_user, answer_list)
    #if user choosed cancellation
    elif answer_type == 'cancel':
        await cancel_mentor(update)
    #if user choosing quiz buttons
    elif answer_type == 'comp':
        await compententions_quiz(context, query, answer_list, tg_username, om_user, om_grade)


async def post_daily_message(context: ContextTypes.DEFAULT_TYPE) -> None:
    """post_daily_message"""
    om_filter = "'–ù–µ—Ç –æ—Ü–µ–Ω–∫–∏' AND NOT IS_PARENT()"
    df = get_om_mc(
        '–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å –º–µ–Ω—Ç–æ—Ä–æ–º',
        view='4BOT',
        formula=om_filter)
    logger.debug('–ù–µ—Ç –æ—Ü–µ–Ω–∫–∏: \n %s', df)
    if not df.empty:
        for index in df.index:
            udf = df.loc[index, :]
            logger.debug('df.row(): \n %s', udf)
            day = udf['Days']
            dtdelta = datetime.today() - datetime.strptime(day, "%d %b %y")
            if dtdelta.days >= 7:
                user_id = udf['Telegram_id']
                user = udf['Telegram_login']
                txt = f'''–ü—Ä–∏–≤–µ—Ç, {user}! –ù–µ –∑–∞–±—É–¥—å –æ—Ü–µ–Ω–∏—Ç—å —Ä–∞–±–æ—Ç—É –º–µ–Ω—Ç–æ—Ä–∞ –ø–æ –∫–æ–º–∞–Ω–¥–µ /mentor,
–≥–¥–µ 5 - –Ω–∞–∏–≤—ã—Å—à–∞—è –æ—Ü–µ–Ω–∫–∞ (–≤–æ–ø—Ä–æ—Å —Ä–µ—à–µ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é, –≤–∑–∞–∏–º–æ–¥–π—Å—Ç–≤–∏–µ –±—ã–ª–æ –∫–æ–º—Ñ–æ—Ä—Ç–Ω—ã–º), –∞ 1 - –≤–æ–ø—Ä–æ—Å –Ω–µ —Ä–µ—à–µ–Ω —Å–æ–≤—Å–µ–º.
–ï—Å–ª–∏ –≤—ã –≤—Å–µ –µ—â–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–µ—à–µ–Ω–∏—è –∫–µ–π—Å–∞, –Ω–∞–ø–æ–º–∏–Ω–∞—é, —á—Ç–æ –≤–∞–º –≤—ã–¥–µ–ª—è–µ—Ç—Å—è 4 —á–∞—Å–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã, –∏—Ö –º–æ–∂–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–∫ —É–¥–æ–±–Ω–æ.  
–§–ê/–¢–ê/–≠—Ç–∞–ø –¥–ª—è –≤—Å—Ç—Ä–µ—á–∏: OT_–ü—Ä–æ—á–∏–µ HR –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ 2024, –ü—Ä–æ—á–∏–µ HR –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏, –ù–∞—Å—Ç–∞–≤–Ω–∏—á–µ—Å—Ç–≤–æ.
–ï—Å–ª–∏ —Ä–∞–∑–æ–±—Ä–∞–ª—Å—è —Å–∞–º –∏–ª–∏ –æ—à–∏–±—Å—è —Å –≤—ã–±–æ—Ä–æ–º –º–µ–Ω—Ç–æ—Ä–∞, —Ç–æ –≤—Å–µ —Ä–∞–≤–Ω–æ –ø—Ä–æ–π–¥–∏ –≤ –º–µ–Ω—é –æ—Ü–µ–Ω–∫–∏ –∏ –≤—ã–±–µ—Ä–∏ —Å–∞–º—ã–π –Ω–∏–∂–Ω–∏–π –≤–∞—Ä–∏–∞–Ω—Ç'''
                await context.bot.send_message(
                    user_id,
                    txt,
                    parse_mode=ParseMode.HTML,
                )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Displays info on how to use the bot."""
    await update.message.reply_text("Use /start to test this bot.")


def main() -> None:
    """Run the bot."""
    # Create the Application and pass it your bot's token.
    application = Application.builder().token(TBOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button))
    email_filter = filters.Regex('@optiteam.ru')
    application.add_handler(MessageHandler(email_filter, login))
    discord_filter = filters.Regex(r'^[^\/][a-z]{4,20}')
    application.add_handler(MessageHandler(discord_filter, own_mentor))
    application.add_handler(CommandHandler("mentor", assess_mentor))
    #application.add_handler(CommandHandler("help", help_command))
    
    # Run schedule job
    dt = time(hour=10, tzinfo=timezone('Europe/Moscow'))
    application.job_queue.run_daily(post_daily_message, dt, name='user_alert')
    # Run the bot until the user presses Ctrl-C
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
